<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Pong – Touch‑Buttons wandern mit dem Feld (v1.1.1)</title>
<style>
  /* ----- Gesamtlayout ------------------------------------------ */
  body{
    margin:0;
    background:#000;
    display:flex;
    justify-content:center;   /* horizontal zentrieren */
    align-items:flex-start;   /* vertikal oben beginnen */
    height:100vh;             /* volle Höhe für das Scroll‑Verhalten */
    padding-top:1rem;         /* kleiner Abstand zum oberen Rand */
  }

  .wrapper{
    position:relative;
    width:80vw;               /* Canvas + Buttons skalieren */
    max-width:600px;
  }

  canvas{
    width:100%;               /* responsiv */
    height:auto;
    background:#111;
    border:2px solid #555;
    display:block;
  }

  /* ----- Touch‑Buttons (klein, folgen dem Canvas) ------------ */
  .controls{
    position:absolute;
    left:50%;
    top: calc(100% + 0.5rem);   /* knapp unter dem Canvas */
    transform:translateX(-50%);
    display:grid;
    grid-template-areas:
      ". up ."
      "left . right"
      ". down .";
    gap:0.4rem;
  }

  .controls button{
    /* halb so groß wie im ursprünglichen Layout */
    --size: calc(6vw + 6vh);
    width:var(--size);
    height:var(--size);
    font-size:calc(var(--size) * 0.4);
    border:none;
    border-radius:8px;
    background:#fff7;
    color:#222;
    cursor:pointer;
    user-select:none;
  }
  .controls button:active{background:#fff9;}

  .up   {grid-area:up;}
  .down {grid-area:down;}
  .left {grid-area:left;}
  .right{grid-area:right;}
</style>
</head>
<body>

<div class="wrapper">
  <canvas id="pong" width="600" height="400"></canvas>

  <!-- Touch‑Buttons -->
  <div class="controls">
    <button class="up">↑</button>
    <button class="left">←</button>
    <button class="right">→</button>
    <button class="down">↓</button>
  </div>
</div>

<script>
/* -------------------------------------------------
   Grundvariablen
   ------------------------------------------------- */
const canvas = document.getElementById('pong');
const ctx    = canvas.getContext('2d');

const paddleW = 10, paddleH = 80, ballR = 8;
let   largeBallExists = false;

/* ---- Player ---- */
const player = {x:10, y:canvas.height/2-paddleH/2,
  w:paddleW, h:paddleH, score:0, maxDistX:null};

/* ---- Computer ---- */
const computer = {x:canvas.width-paddleW-10,
  y:canvas.height/2-paddleH/2,
  w:paddleW, h:paddleH, score:0, maxDistX:null};

/* ---- Normale Bälle ---- */
function createBall(){ return {
  x:canvas.width/2, y:canvas.height/2,
  vx:4*(Math.random()>0.5?1:-1),
  vy:2*(Math.random()>0.5?1:-1),
  r:ballR };
};
let balls = [createBall()];

/* ---- Tastatur‑/Touch‑State ---- */
const keys = {};
document.addEventListener('keydown', e=>keys[e.key]=true);
document.addEventListener('keyup',   e=>keys[e.key]=false);

/* Touch‑Buttons → simulieren dieselben keys */
function press(key){ keys[key]=true; }
function release(key){ keys[key]=false; }
document.querySelectorAll('.controls button').forEach(btn=>{
  const map = {up:'ArrowUp',down:'ArrowDown',
               left:'ArrowLeft',right:'ArrowRight'};
  const key = map[btn.className];
  btn.addEventListener('pointerdown',()=>press(key));
  btn.addEventListener('pointerup',  ()=>release(key));
  btn.addEventListener('pointerleave',()=>release(key));
});

/* ---- Feuerwerk ---- */
let fireworks = [];
const fireworkCount = 30, fireworkSpeed = 3;
function spawnFirework(){
  const cx=canvas.width/2, cy=canvas.height/2;
  for(let i=0;i<fireworkCount;i++){
    const a=Math.random()*Math.PI*2;
    const s=Math.random()*fireworkSpeed+1;
    fireworks.push({x:cx,y:cy,
      vx:Math.cos(a)*s, vy:Math.sin(a)*s,
      life:30,
      color:`hsl(${Math.random()*360},80%,60%)`});
  }
}
function updateFirework(){
  fireworks.forEach(p=>{p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; p.life--;});
  fireworks = fireworks.filter(p=>p.life>0);
}
function drawFirework(){
  fireworks.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.globalAlpha=p.life/30;
    ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  });
}

/* -------------------------------------------------
   Hilfsfunktionen
   ------------------------------------------------- */
function drawRect(x,y,w,h,c){ctx.fillStyle=c; ctx.fillRect(x,y,w,h);}
function drawCircle(x,y,r,c){
  ctx.fillStyle=c;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath(); ctx.fill();
}
function collide(ball,p){
  return ball.x-ball.r < p.x+p.w &&
         ball.x+ball.r > p.x &&
         ball.y-ball.r < p.y+p.h &&
         ball.y+ball.r > p.y;
}

/* -------------------------------------------------
   Max‑Dist‑Werte (Mittellinie)
   ------------------------------------------------- */
function initMaxDist(){
  player.maxDistX   = (canvas.width/2) - (player.x+player.w);
  computer.maxDistX = computer.x - (canvas.width/2);
}
initMaxDist();

/* -------------------------------------------------
   KI – Ziel‑Ball für den Gegner
   ------------------------------------------------- */
function getTargetBall(){
  let best=null, bestTime=Infinity;
  balls.forEach(b=>{
    if(b.vx>0){
      const t=(computer.x-b.x)/b.vx;
      if(t<bestTime){bestTime=t; best=b;}
    }
  });
  return best||balls[0];
}

/* -------------------------------------------------
   Update – Spiel‑Logik
   ------------------------------------------------- */
function update(){
  /* ---- Player ---- */
  if(keys['ArrowUp'])    player.y -= 6;
  if(keys['ArrowDown'])  player.y += 6;
  player.y = Math.max(0, Math.min(canvas.height-paddleH, player.y));

  // horizontal movement
  if(keys['ArrowRight']) player.x += 6;   // normal
  if(keys['ArrowLeft'])  player.x -= 3;   // zurück = halb
  player.x = Math.max(10,
            Math.min(canvas.width/2 - paddleW, player.x));

  /* ---- Computer – KI vertikal ---- */
  const target = getTargetBall();
  const dx   = computer.x - target.x;
  const predY = target.y + (dx/target.vx)*target.vy;
  const goalY = Math.min(Math.max(predY, paddleH/2), canvas.height-paddleH/2);
  if(computer.y + paddleH/2 < goalY) computer.y += 4;
  else if(computer.y + paddleH/2 > goalY) computer.y -= 4;
  computer.y = Math.max(0, Math.min(canvas.height-paddleH, computer.y));

  /* ---- Random großer Ball (nur einer) ---- */
  if(!largeBallExists && Math.random()<0.004){
    largeBallExists = true;
    balls.push({x:canvas.width/2, y:canvas.height/2,
      vx:4*(Math.random()>0.5?1:-1),
      vy:2*(Math.random()>0.5?1:-1),
      r:ballR*3,
      color:'#f0f'});
  }

  /* ---- Bälle durchgehen ---- */
  balls.forEach((ball,i)=>{
    ball.x += ball.vx;
    ball.y += ball.vy;
    if(ball.y-ball.r<0 || ball.y+ball.r>canvas.height) ball.vy*=-1;

    // Kollision Player
    if(collide(ball,player) && ball.vx<0){
      const curDist = (canvas.width/2)-(player.x+player.w);
      const factor  = 1 - curDist/player.maxDistX;
      const mult    = 1 + factor;
      ball.vx = -ball.vx * mult;
      ball.vy = (ball.y-(player.y+paddleH/2))*0.15;
    }
    // Kollision Computer
    if(collide(ball,computer) && ball.vx>0){
      const curDist = computer.x-(canvas.width/2);
      const factor  = 1 - curDist/computer.maxDistX;
      const mult    = 1 + factor;
      ball.vx = -ball.vx * mult;
      ball.vy = (ball.y-(computer.y+paddleH/2))*0.15;
    }

    // Punkt erreicht?
    if(ball.x<0){                // Computer punktet
      const pts = (ball.r===ballR*3)?10:1;
      computer.score += pts;
      spawnFirework();
      if(ball.r===ballR*3){
        balls.splice(i,1);
        largeBallExists = false;
      }else{
        ball.x = canvas.width/2; ball.y = canvas.height/2;
        ball.vx = 4*(Math.random()>0.5?1:-1);
        ball.vy = 2*(Math.random()>0.5?1:-1);
        const normCnt = balls.filter(b=>b.r===ballR).length;
        if(normCnt<5) balls.push(createBall());
      }
    } else if(ball.x>canvas.width){ // Player punktet
      const pts = (ball.r===ballR*3)?10:1;
      player.score += pts;
      spawnFirework();
      if(ball.r===ballR*3){
        balls.splice(i,1);
        largeBallExists = false;
      }else{
        ball.x = canvas.width/2; ball.y = canvas.height/2;
        ball.vx = 4*(Math.random()>0.5?1:-1);
        ball.vy = 2*(Math.random()>0.5?1:-1);
        const normCnt = balls.filter(b=>b.r===ballR).length;
        if(normCnt<5) balls.push(createBall());
      }
    }
  });

  updateFirework();
}

/* -------------------------------------------------
   Render
   ------------------------------------------------- */
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRect(player.x,player.y,player.w,player.h,'#fff');
  drawRect(computer.x,computer.y,computer.w,computer.h,'#fff');

  balls.forEach(b=>{
    const col = (b.r===ballR*3)?'#f0f':'#ff0';
    drawCircle(b.x,b.y,b.r,col);
  });

  ctx.fillStyle='#fff';
  ctx.font='20px Arial';
  ctx.fillText(player.score,   canvas.width/4,30);
  ctx.fillText(computer.score, 3*canvas.width/4,30);

  drawFirework();
}

/* -------------------------------------------------
   Haupt‑Loop
   ------------------------------------------------- */
function loop(){ update(); render(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
